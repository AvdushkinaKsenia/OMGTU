def ford_bellman(graph, start, end):
    n = len(graph)
    distance = [float('inf')] * n
    parent = [-1] * n
    distance[start] = 0

    for _ in range(n - 1):
        for u in range(n):
            for v in range(n):
                if graph[u][v] != 0 and distance[u] + graph[u][v] < distance[v]:
                    distance[v] = distance[u] + graph[u][v]
                    parent[v] = u

    for u in range(n):
        for v in range(n):
            if graph[u][v] != 0 and distance[u] + graph[u][v] < distance[v]:
                print("Graph contains negative cycle")
                return

    path = []
    current = end
    while current != -1:
        path.append(current + 1)
        current = parent[current]
    path = path[::-1]

    return distance[end], path

#Граф с отрицательным циклом
# weight_matrix = [
#     [0, 4, 4, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 4, -2, 0, 0],
#     [3, 0, 2, 0, 0, 0, 0, 0],
#     [0, 0, 0, 1, 0, 0, -2, 0],
#     [0, 3, 0, 0, -3, 0, 0, 0],
#     [0, 0, 0, 0, 0, 2, 0, 2],
#     [0, 0, 0, 0, -2, 0, 0, 0]
# ]

weight_matrix = [
    [0, 1, 0, 0, 3],
    [0, 0, 8, 7, 1],
    [0, 0, 0, 1, -5],
    [0, 0, 2, 0, 0],
    [0, 0, 0, 4, 0]
]
start_vertex = int(input("Start vertex: ")) - 1
end_vertex = int(input("End vertex: ")) - 1
distance, path = ford_bellman(weight_matrix, start_vertex, end_vertex)
print("Shortest distance:", distance)
print("Shortest path:", path)
